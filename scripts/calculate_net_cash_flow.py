import pandas as pd
import numpy as np
from sqlalchemy import create_engine

# File Paths
forecast_components_input_path = "baseline_forecasts_ALL_COMPONENTS.csv"
historical_prepared_data_path = "prepared_cash_flow_data.csv"
capex_file_path = "Monthly_Mock_CapEx.csv"
final_output_path = "final_cash_flow_summary_baseline.csv"

# Configuration
forecast_horizon_months = 24

print("Starting Net Cash Flow Aggregation Process...")

# 1. Load Data
try:
    # Load component forecasts generated by the Prophet model script
    df_forecasts_components = pd.read_csv(forecast_components_input_path, parse_dates=['ds'])

    # Load the full historical dataset to source actuals like debt and interest
    df_historical_full_raw = pd.read_csv(historical_prepared_data_path)
    
    # Identify and standardize the date column from the historical data
    date_col_in_historical_full = None
    if 'ds' in df_historical_full_raw.columns:
        date_col_in_historical_full = 'ds'
    elif 'statement_date' in df_historical_full_raw.columns:
        date_col_in_historical_full = 'statement_date'
    elif 'balance_date' in df_historical_full_raw.columns:
        date_col_in_historical_full = 'balance_date'
    elif df_historical_full_raw.columns[0].lower() == 'date' or df_historical_full_raw.columns[0].lower().endswith('_date'):
        if pd.api.types.is_datetime64_any_dtype(pd.to_datetime(df_historical_full_raw.iloc[:, 0], errors='coerce')):
             date_col_in_historical_full = df_historical_full_raw.columns[0]
    elif 'Unnamed: 0' in df_historical_full_raw.columns:
        if pd.api.types.is_datetime64_any_dtype(pd.to_datetime(df_historical_full_raw['Unnamed: 0'], errors='coerce')):
            date_col_in_historical_full = 'Unnamed: 0'
            
    if not date_col_in_historical_full:
        raise ValueError(f"Could not identify a date column in '{historical_prepared_data_path}'.")

    df_historical_full = df_historical_full_raw.copy()
    df_historical_full[date_col_in_historical_full] = pd.to_datetime(df_historical_full[date_col_in_historical_full])
    if date_col_in_historical_full != 'ds':
        df_historical_full.rename(columns={date_col_in_historical_full: 'ds'}, inplace=True)
    
    # Load future capital expenditure data
    df_capex_future = pd.read_csv(capex_file_path, parse_dates=['Date'])
    df_capex_future.rename(columns={'Date': 'ds', 'CapEx_Amount': 'capex_outflow'}, inplace=True)
    df_capex_future['ds'] = pd.to_datetime(df_capex_future['ds']) + pd.offsets.MonthEnd(0)
    
    print("Data loaded successfully.")

except FileNotFoundError as e:
    print(f"ERROR: Input data file not found: {e}")
    exit()
except ValueError as ve:
    print(f"ERROR: {ve}")
    exit()
except Exception as e:
    print(f"Error loading input data: {e}")
    exit()

# Prepare the main working DataFrame by merging all data sources
df_merged = df_forecasts_components.copy()

# Define and merge required historical data fields
hist_cols_to_bring_in = {
    'interest_expense': 'interest_expense_actual_hist',
    'taxes': 'taxes_actual_hist',
    'long_term_debt': 'long_term_debt_hist',
    'short_term_debt': 'short_term_debt_hist',
    'net_debt_financing_activity': 'net_debt_financing_activity_hist'
}

cols_to_select_from_hist = ['ds']
temp_rename_map_for_merge = {'ds': 'ds'}

for original_name, new_merged_name in hist_cols_to_bring_in.items():
    if original_name in df_historical_full.columns:
        cols_to_select_from_hist.append(original_name)
        temp_rename_map_for_merge[original_name] = new_merged_name
    else:
        print(f"Warning: Column '{original_name}' not found in historical data. It will be treated as missing.")
        df_merged[new_merged_name] = np.nan

df_historical_subset = df_historical_full[list(set(cols_to_select_from_hist))].copy()
df_historical_subset.rename(columns=temp_rename_map_for_merge, inplace=True)

df_merged = pd.merge(df_merged, df_historical_subset, on='ds', how='left')

# Merge future CapEx data
df_capex_subset = df_capex_future[['ds', 'capex_outflow']].copy()
df_merged = pd.merge(df_merged, df_capex_subset, on='ds', how='left')
df_merged['capex_outflow'] = df_merged['capex_outflow'].fillna(0)
print("CapEx data merged and NaNs filled.")

# 2. Project Intermediate Financial Components for Forecast Period
forecast_start_date = df_merged[df_merged['inflow_operating_revenue_actual'].isnull()]['ds'].min()
print(f"Forecast period starts from: {forecast_start_date}")

# Project future Long-Term Debt for interest calculation
last_actual_long_term_debt = 0
if 'long_term_debt_hist' in df_merged.columns:
    historical_ltd = df_merged.loc[df_merged['ds'] < forecast_start_date, 'long_term_debt_hist'].dropna()
    if not historical_ltd.empty:
        last_actual_long_term_debt = historical_ltd.iloc[-1]
else:
    print(f"WARNING: 'long_term_debt_hist' not found. Future interest will be based on 0 debt.")
print(f"Using last actual Long-Term Debt for future interest projection: {last_actual_long_term_debt}")

df_merged['long_term_debt_projected_for_interest'] = np.nan
df_merged.loc[df_merged['ds'] >= forecast_start_date, 'long_term_debt_projected_for_interest'] = last_actual_long_term_debt
df_merged['long_term_debt_projected_for_interest'] = df_merged['long_term_debt_projected_for_interest'].ffill()

# Project Net Debt Financing Activity
df_merged['net_debt_financing_activity_forecast'] = 0 # Assume no net new debt/repayment in forecast
df_merged['net_debt_financing_activity_final'] = df_merged.get('net_debt_financing_activity_hist', pd.Series(0.0, index=df_merged.index)).fillna(df_merged['net_debt_financing_activity_forecast'])

# Calculate Interest Outflow
df_merged['outflow_interest_forecast_calc'] = (df_merged['long_term_debt_projected_for_interest'].fillna(0) * 0.03) / 12
df_merged['outflow_interest_final'] = df_merged.get('interest_expense_actual_hist', pd.Series(np.nan, index=df_merged.index)).fillna(df_merged['outflow_interest_forecast_calc'])

# Calculate EBIT
df_merged['ebit_actual_calc'] = (df_merged['inflow_operating_revenue_actual'].fillna(df_merged['inflow_operating_revenue_forecast']) -
                                (df_merged['outflow_cogs_actual'].fillna(df_merged['outflow_cogs_forecast']) +
                                 df_merged['outflow_opex_actual'].fillna(df_merged['outflow_opex_forecast'])))
df_merged['ebit_forecast_calc'] = (df_merged['inflow_operating_revenue_forecast'] -
                                  (df_merged['outflow_cogs_forecast'] +
                                   df_merged['outflow_opex_forecast']))
df_merged['ebit_final'] = df_merged['ebit_actual_calc'].fillna(df_merged['ebit_forecast_calc'])

# Calculate Tax Outflow
df_merged['ebt_final_for_taxes'] = df_merged['ebit_final'].fillna(0) - df_merged['outflow_interest_final'].fillna(0)
df_merged['outflow_taxes_forecast_calc'] = np.where(df_merged['ebt_final_for_taxes'] > 0,
                                                   df_merged['ebt_final_for_taxes'] * 0.25,
                                                   0)
df_merged['outflow_taxes_final'] = df_merged.get('taxes_actual_hist', pd.Series(np.nan, index=df_merged.index)).fillna(df_merged['outflow_taxes_forecast_calc'])

# 3. Calculate Aggregate Cash Flow Lines
df_merged['net_operating_cash_flow_final'] = (
    df_merged['inflow_operating_revenue_actual'].fillna(df_merged['inflow_operating_revenue_forecast']) -
    (df_merged['outflow_cogs_actual'].fillna(df_merged['outflow_cogs_forecast']) +
     df_merged['outflow_opex_actual'].fillna(df_merged['outflow_opex_forecast']) +
     df_merged['outflow_interest_final'] +
     df_merged['outflow_taxes_final'])
)
df_merged['net_investing_cash_flow_final'] = -df_merged['capex_outflow'].fillna(0)
df_merged['net_financing_cash_flow_final'] = df_merged['net_debt_financing_activity_final'].fillna(0)

df_merged['net_change_in_cash_total_final'] = (
    df_merged['net_operating_cash_flow_final'].fillna(0) +
    df_merged['net_investing_cash_flow_final'].fillna(0) +
    df_merged['net_financing_cash_flow_final'].fillna(0)
)

# 4. Display and Save Output
print("\nFinal Merged DataFrame Head (with Aggregates):")
display_cols = [
    'ds',
    'inflow_operating_revenue_actual', 'inflow_operating_revenue_forecast',
    'outflow_cogs_actual', 'outflow_cogs_forecast',
    'outflow_opex_actual', 'outflow_opex_forecast',
    'interest_expense_actual_hist', 'outflow_interest_final',
    'taxes_actual_hist', 'outflow_taxes_final',
    'capex_outflow',
    'long_term_debt_hist', 'short_term_debt_hist',
    'net_debt_financing_activity_hist', 'net_debt_financing_activity_final',
    'ebit_final', 'ebt_final_for_taxes',
    'net_operating_cash_flow_final',
    'net_investing_cash_flow_final',
    'net_financing_cash_flow_final',
    'net_change_in_cash_total_final'
]
existing_display_cols = [col for col in display_cols if col in df_merged.columns]
print(df_merged[existing_display_cols].head())

print("\nFinal Merged DataFrame Tail (with Aggregates):")
print(df_merged[existing_display_cols].tail(forecast_horizon_months + 3))

df_merged.info(verbose=True, show_counts=True)

try:
    df_merged.sort_values(by='ds', inplace=True)
    df_merged.to_csv(final_output_path, index=False)
    print(f"\nSuccessfully saved final aggregated cash flow summary to: {final_output_path}")
except Exception as e:
    print(f"Error saving final aggregated data: {e}")

print("\nNet Cash Flow Aggregation Process Completed.")